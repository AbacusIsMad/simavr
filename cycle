sim/doc/manual/simavr.tex:platform with avr-libc support.
sim/doc/manual/simavr.tex:    avr->gdb_port = 1234;
sim/doc/manual/simavr.tex:    avr->state = cpu_Stopped;
sim/doc/manual/simavr.tex:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, 2, _ee_irq_names);
sim/doc/manual/simavr.tex:(\lstinline|avr->run|\footnote{Whenever \lstinline|avr| is mentioned in a code
sim/doc/manual/simavr.tex:    avr_gdb_processor(avr, avr->state == cpu_Stopped);
sim/doc/manual/simavr.tex:    if (avr->state == cpu_Stopped)
sim/doc/manual/simavr.tex:    int step = avr->state == cpu_Step;
sim/doc/manual/simavr.tex:        avr->state = cpu_Running;
sim/doc/manual/simavr.tex:    avr_flashaddr_t new_pc = avr->pc;
sim/doc/manual/simavr.tex:    if (avr->state == cpu_Running) {
sim/doc/manual/simavr.tex:(\lstinline|avr->flash|) and triggers all necessary actions. This can include setting the \ac{CPU}
sim/doc/manual/simavr.tex:Finally, the cycle counter (\lstinline|avr->cycle|) is updated and the new
sim/doc/manual/simavr.tex:    if (avr->sreg[S_I] && !avr->i_shadow)
sim/doc/manual/simavr.tex:        avr->interrupts.pending_wait++;
sim/doc/manual/simavr.tex:    avr->i_shadow = avr->sreg[S_I];
sim/doc/manual/simavr.tex:    avr->pc = new_pc;
sim/doc/manual/simavr.tex:    if (avr->state == cpu_Sleeping) {
sim/doc/manual/simavr.tex:        if (!avr->sreg[S_I]) {
sim/doc/manual/simavr.tex:            avr->state = cpu_Done;
sim/doc/manual/simavr.tex:        avr->sleep(avr, sleep);
sim/doc/manual/simavr.tex:        avr->cycle += 1 + sleep;
sim/doc/manual/simavr.tex:stored in \lstinline|avr->sleep|. In \ac{GDB} mode, the time is used to listen for
sim/doc/manual/simavr.tex:    if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
sim/doc/manual/simavr.tex:        avr->state = cpu_StepDone;
sim/doc/manual/simavr.tex:source tree and are compiled conditionally depending on the the local \emph{avr-libc}
sim/doc/manual/simavr.tex:If \ac{GDB} support is desired, \lstinline|avr->gdb_port| must be set, and
sim/doc/manual/simavr.tex:set the \lstinline|avr->run| and \lstinline|avr->sleep| callbacks, and listen
sim/doc/manual/simavr.tex:(\lstinline|avr->state = cpu_Stopped|) to delay program execution until it
sim/doc/manual/simavr.tex:Besides loading the program code into \lstinline|avr->flash| (and \ac{EEPROM} contents
sim/doc/manual/simavr.tex:into \lstinline|avr->eeprom|, if available), there are several useful extended
sim/doc/manual/simavr.tex:by binding \lstinline|stdout| to \lstinline|UART0| as described by the avr-libc
sim/doc/manual/simavr.tex:\lstinline|avr->flash[avr->pc]|. \lstinline|avr->pc| points to the \ac{LSB}, and
sim/doc/manual/simavr.tex:\lstinline|avr->pc + 1| to the \ac{MSB}. Thus, the full opcode is reconstructed with:
sim/doc/manual/simavr.tex:uint32_t opcode = (avr->flash[avr->pc + 1] << 8) | avr->flash[avr->pc];
sim/doc/manual/simavr.tex:As we have seen, \lstinline|avr->pc| represents the byte address in flash memory.
sim/doc/manual/simavr.tex:Therefore, the next instruction is located at \lstinline|avr->pc + 2|. This
sim/doc/manual/simavr.tex:(\lstinline|avr->pc >> 1|).
sim/doc/manual/simavr.tex:The status register is stored in \lstinline|avr->sreg| as a byte array.
sim/doc/manual/simavr.tex:firmware reads from \ac{SREG}, it must be reconstructed from \lstinline|avr->sreg|.
sim/doc/manual/simavr.tex:Upon conclusion, \lstinline|avr->cycle| is updated with the actual instruction
sim/doc/manual/simavr.tex:\lstinline|avr->interrupts|.
sim/doc/manual/simavr.tex:\lstinline|avr->interrupts|, and a non-zero \lstinline|pending_wait| time is
sim/doc/manual/simavr.tex:    _avr_push16(avr, avr->pc >> 1);
sim/doc/manual/simavr.tex:    avr->sreg[S_I] = 0;
sim/doc/manual/simavr.tex:    avr->pc = vector->vector * avr->vector_size;
sim/doc/manual/simavr.tex:the difference between byte addresses (as used in \lstinline|avr->pc|) and
sim/doc/manual/simavr.tex:\lstinline|avr->sleep|, even if an external event causing \ac{CPU} wakeup is
sim/doc/manual/simavr.tex:which allows it to communicate with \emph{avr-gdb}. A complete reference of
sim/doc/manual/simavr.tex:on the \lstinline|avr->gdb_port|.
sim/doc/manual/simavr.tex:struct in \lstinline|avr->gdb| and are limited to 32 active instances of each.
sim/doc/manual/simavr.tex:port is specified. It is therefore always a good idea to initialize \lstinline|avr->gdb_port|, even
sim/doc/manual/simavr.tex:write callback instead of setting \lstinline|avr->data| directly:
sim/doc/manual/simavr.tex:    if (avr->io[io].w.c)
sim/doc/manual/simavr.tex:        avr->io[io].w.c(avr, r, v, avr->io[io].w.param);
sim/doc/manual/simavr.tex:        avr->data[r] = v;
sim/doc/manual/simavr.tex:    if (avr->io[io].irq) {
sim/doc/manual/simavr.tex:        avr_raise_irq(avr->io[io].irq + AVR_IOMEM_IRQ_ALL, v);
sim/doc/manual/simavr.tex:            avr_raise_irq(avr->io[io].irq + i, (v >> i) & 1);
sim/doc/manual/simavr.tex:Next up, we see that write callbacks need to set the \lstinline|avr->data| value
sim/doc/manual/simavr.tex:by the callback is automatically written to \lstinline|avr->data|.
sim/doc/manual/simavr.tex:in the \lstinline|avr->io| array. \lstinline|MAX_IOs| is currently set to
sim/doc/manual/simavr.tex:of all modules registered in the \lstinline|avr->io_port| linked list is called
sim/doc/manual/simavr.tex:\emph{avr-libc} headers to specify the internal structure of an \ac{MCU} needed
sim/doc/manual/simavr.tex:} initializes basic parameters included in \emph{avr-libc}
sim/doc/manual/simavr.tex:bit locations rely on \emph{avr-libc} definitions:
sim/doc/manual/simavr.tex:of \emph{avr-libc} and a datasheet.
sim/doc/manual/setupguide.tex:At compile-time, \simavr additionally requires \emph{avr-libc} to complete its
sim/doc/manual/setupguide.tex:\item avr-libc 1.8.0
sim/doc/manual/setupguide.tex:The path to the system's \emph{avr-libc} installation.
sim/doc/manual/setupguide.tex:message 'WARNING \ldots did not compile, check your avr-gcc
sim/examples/board_hd44780/README:avr-libc one, a much more complete one.
Binary file sim/examples/board_hd44780/atmega48_charlcd.axf matches
sim/examples/board_i2ctest/i2ctest.c:	avr->gdb_port = 1234;
sim/examples/board_i2ctest/i2ctest.c:		//avr->state = cpu_Stopped;
Binary file sim/examples/board_i2ctest/atmega1280_i2ctest.axf matches
sim/examples/result/include/simavr/parts/hd44780.h: * avr-libc example code.
Binary file sim/examples/board_ssd1306/atmega32_ssd1306.axf matches
sim/examples/board_simduino/README:	uart_pty_connect: /tmp/simavr-uart0 now points to /dev/pts/11
sim/examples/board_simduino/README:% avrdude -p m328p -c arduino -P /tmp/simavr-uart0 -U flash:w:atmega328p_dummy_blinky.hex
Binary file sim/examples/board_simduino/obj-x86_64-linux-gnu/uart_pty.o matches
Binary file sim/examples/board_simduino/obj-x86_64-linux-gnu/simduino.elf matches
sim/examples/board_simduino/simduino.c:	(void)ftruncate(flash_data->avr_flash_fd, avr->flashend + 1);
sim/examples/board_simduino/simduino.c:	ssize_t r = read(flash_data->avr_flash_fd, avr->flash, avr->flashend + 1);
sim/examples/board_simduino/simduino.c:	if (r != avr->flashend + 1) {
sim/examples/board_simduino/simduino.c:	ssize_t r = write(flash_data->avr_flash_fd, avr->flash, avr->flashend + 1);
sim/examples/board_simduino/simduino.c:	if (r != avr->flashend + 1) {
sim/examples/board_simduino/simduino.c:	avr->custom.init = avr_special_init;
sim/examples/board_simduino/simduino.c:	avr->custom.deinit = avr_special_deinit;
sim/examples/board_simduino/simduino.c:	avr->custom.data = &flash_data;
sim/examples/board_simduino/simduino.c:	avr->frequency = freq;
sim/examples/board_simduino/simduino.c:	memcpy(avr->flash + boot_base, boot, boot_size);
sim/examples/board_simduino/simduino.c:	avr->pc = boot_base;
sim/examples/board_simduino/simduino.c:	avr->codeend = avr->flashend;
sim/examples/board_simduino/simduino.c:	avr->log = 1 + verbose;
sim/examples/board_simduino/simduino.c:	avr->gdb_port = 1234;
sim/examples/board_simduino/simduino.c:		avr->state = cpu_Stopped;
sim/examples/parts/uart_pty.c:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_UART_PTY_COUNT, irq_names);
sim/examples/parts/uart_pty.c:		snprintf(link, sizeof(link), "/tmp/simavr-uart%c%s", uart, ti == 1 ? "-tap" : "");
sim/examples/parts/ds1338_virt.c:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, DS1338_IRQ_COUNT, _ds1338_irq_names);
sim/examples/parts/result/include/simavr/parts/hd44780.h: * avr-libc example code.
sim/examples/parts/hc595.c:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_HC595_COUNT, irq_names);
sim/examples/parts/hd44780.c:	b->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_HD44780_COUNT, irq_names);
sim/examples/parts/i2c_eeprom.c:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, 2, _ee_irq_names);
sim/examples/parts/button.c:	b->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_BUTTON_COUNT, &name);
Binary file sim/examples/parts/obj-x86_64-linux-gnu/libsimavrparts.a matches
Binary file sim/examples/parts/obj-x86_64-linux-gnu/uart_pty.o matches
Binary file sim/examples/parts/obj-x86_64-linux-gnu/libsimavrparts.so.1 matches
sim/examples/parts/rotenc.c:			&avr->irq_pool,
sim/examples/parts/hd44780.h: * avr-libc example code.
sim/examples/parts/ac_input.c:	b->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_AC_COUNT, &name);
sim/examples/parts/uart_udp.c:	p->irq = avr_alloc_irq(&avr->irq_pool, 0, IRQ_UART_UDP_COUNT, irq_names);
sim/examples/parts/ssd1306_virt.c:	part->irq = avr_alloc_irq (&avr->irq_pool, 0, IRQ_SSD1306_COUNT,
Binary file sim/examples/board_ledramp/atmega48_ledramp.axf matches
sim/examples/board_ledramp/ledramp.c:	avr->gdb_port = 1234;
sim/examples/board_ledramp/ledramp.c:		//avr->state = cpu_Stopped;
Binary file sim/examples/board_timer_64led/atmega168_timer_64led.axf matches
sim/examples/board_timer_64led/timer_64led.c:	avr->gdb_port = 1234;
sim/examples/board_timer_64led/timer_64led.c:		//avr->state = cpu_Stopped;
sim/examples/board_rotenc/rotenc_test.c:	//avr->gdb_port = 1234;
sim/examples/board_rotenc/rotenc_test.c:	//avr->state = cpu_Stopped;
Binary file sim/examples/board_rotenc/atmega32_rotenc_test.axf matches
sim/examples/extra_board_usb/simusb.c:	if(avr->flash) free(avr->flash);
sim/examples/extra_board_usb/simusb.c:	(void)ftruncate(flash_data->avr_flash_fd, avr->flashend + 1);
sim/examples/extra_board_usb/simusb.c:	avr->flash = (uint8_t*)mmap(NULL, avr->flashend + 1, // 32k is multiple of 4096
sim/examples/extra_board_usb/simusb.c:	if (!avr->flash) {
sim/examples/extra_board_usb/simusb.c:	munmap( avr->flash, avr->flashend + 1);
sim/examples/extra_board_usb/simusb.c:	avr->flash = NULL;
sim/examples/extra_board_usb/simusb.c:	avr->custom.init = avr_special_init;
sim/examples/extra_board_usb/simusb.c:	avr->custom.deinit = avr_special_deinit;
sim/examples/extra_board_usb/simusb.c:	avr->custom.data = &flash_data;
sim/examples/extra_board_usb/simusb.c:	//avr->reset = NULL;
sim/examples/extra_board_usb/simusb.c:	avr->frequency = 8000000;
sim/examples/extra_board_usb/simusb.c:		memcpy(avr->flash + base, boot, size);
sim/examples/extra_board_usb/simusb.c:		avr->pc = base;
sim/examples/extra_board_usb/simusb.c:		avr->codeend = avr->flashend;
sim/examples/extra_board_usb/simusb.c:	avr->gdb_port = 1234;
sim/examples/extra_board_usb/simusb.c:		//avr->state = cpu_Stopped;
sim/examples/shared/twimaster.c:* Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
sim/examples/shared/twimaster.h:* Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
sim/examples/board_ds1338/twimaster.c:* Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
Binary file sim/examples/board_ds1338/atmega32_ds1338.axf matches
sim/examples/board_ds1338/ds1338demo.c:	avr->gdb_port = 1234;
sim/examples/board_ds1338/ds1338demo.c:		avr->state = cpu_Stopped;
sim/examples/board_ds1338/i2cmaster.h:* Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
sim/Makefile.common: AVR 		:= ${AVR_ROOT}/bin/avr-
sim/Makefile.common:   $(error Please install avr-gcc: port install avr-gcc avr-libc)
sim/Makefile.common:  AVR 		:= /opt/local/bin/avr-
sim/Makefile.common:  # That's for Homebrew libelf and avr-gcc support
sim/Makefile.common:   ifneq (${shell test -d $(HOMEBREW_PREFIX)/Cellar/avr-gcc* && echo Exists}, Exists)
sim/Makefile.common:    $(error Please install avr-gcc: brew tap osx-cross/homebrew-avr ; brew install avr-libc)
sim/Makefile.common:   AVR_ROOT		:= $(firstword $(wildcard $(HOMEBREW_PREFIX)/Cellar/avr-libc/*/))
sim/Makefile.common:   AVR			:= $(HOMEBREW_PREFIX)/bin/avr-
sim/Makefile.common: AVR 		:= ${AVR_ROOT}/avr-
sim/Makefile.common:AVR		:= avr-
sim/README.md:_simavr_ is an AVR simulator for linux, or any platform that uses avr-gcc. It uses 
sim/README.md:avr-gcc's own register definition to simplify creating new targets for supported AVR
sim/simavr/simavr-avr.pc:Name: simavr-avr
sim/simavr/simavr-avr.pc:Description: Atmel(tm) AVR 8 bits simulator - avr-gcc flags
sim/simavr/sim/avr_adc.c:                    avr->data[p->r_adcl] = p->result & 0xff;
sim/simavr/sim/avr_adc.c:                    avr->data[p->r_adch] = p->result >> 8;
sim/simavr/sim/avr_adc.c:			if ( !avr->vcc) {
sim/simavr/sim/avr_adc.c:				reg = avr->vcc / 4;
sim/simavr/sim/avr_adc.c:			if (!avr->vcc)
sim/simavr/sim/avr_adc.c:				vref = avr->vcc;
sim/simavr/sim/avr_adc.c:			if (!avr->aref)
sim/simavr/sim/avr_adc.c:				vref = avr->aref;
sim/simavr/sim/avr_adc.c:			if (!avr->avcc)
sim/simavr/sim/avr_adc.c:				vref = avr->avcc;
sim/simavr/sim/avr_adc.c:                        v |= (mask & avr->data[p->adsc.reg]);
sim/simavr/sim/avr_adc.c:	avr->data[p->adsc.reg] = v;
sim/simavr/sim/avr_adc.c:		v = avr->data[p->adsc.reg];
sim/simavr/sim/avr_adc.c:		AVR_LOG(avr, LOG_TRACE, "ADC: Start AREF %d AVCC %d\n", avr->aref, avr->avcc);
sim/simavr/sim/avr_adc.c:		v = avr->data[p->adsc.reg];	// Peter Ross pross@xvid.org
sim/simavr/sim/avr_adc.c:                                (avr->frequency >> div) / 13 / 100);
sim/simavr/sim/avr_adc.c:						uint8_t val = avr->data[addr] | (1 << p->adsc.bit);
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:	avr_init_irq(&avr->irq_pool, table->irq,
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:	avr->interrupt_state = 0;
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:	avr_init_irq(&avr->irq_pool, vector->irq,
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:				vector->vector, !!avr->sreg[S_I], avr_regbit_get(avr, vector->enable),
sim/simavr/sim/sim_interrupts.c:				(long long int)avr->cycle, avr->pc);
sim/simavr/sim/sim_interrupts.c:	avr_raise_irq(avr->interrupts.irq + AVR_INT_IRQ_PENDING, vector->vector);
sim/simavr/sim/sim_interrupts.c:		avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:		if (avr->sreg[S_I] && avr->interrupt_state == 0)
sim/simavr/sim/sim_interrupts.c:			avr->interrupt_state = 1;
sim/simavr/sim/sim_interrupts.c:		if (avr->state == cpu_Sleeping) {
sim/simavr/sim/sim_interrupts.c:			avr->state = cpu_Running;	// in case we were sleeping
sim/simavr/sim/sim_interrupts.c:	avr_raise_irq_float(avr->interrupts.irq + AVR_INT_IRQ_PENDING,
sim/simavr/sim/sim_interrupts.c:							&avr->interrupts.pending, 0)->vector : 0,
sim/simavr/sim/sim_interrupts.c:	avr_raise_irq(avr->interrupts.irq + AVR_INT_IRQ_PENDING,
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:	if (!avr->sreg[S_I] || !avr->interrupt_state)
sim/simavr/sim/sim_interrupts.c:	if (avr->interrupt_state < 0) {
sim/simavr/sim/sim_interrupts.c:		avr->interrupt_state++;
sim/simavr/sim/sim_interrupts.c:		if (avr->interrupt_state == 0)
sim/simavr/sim/sim_interrupts.c:			avr->interrupt_state = avr_has_pending_interrupts(avr);
sim/simavr/sim/sim_interrupts.c:	avr_int_table_p table = &avr->interrupts;
sim/simavr/sim/sim_interrupts.c:		avr->interrupt_state = avr_has_pending_interrupts(avr);
sim/simavr/sim/sim_interrupts.c:		_avr_push_addr(avr, avr->pc);
sim/simavr/sim/sim_interrupts.c:		avr->pc = vector->vector * avr->vector_size;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:	avr->run_cycle_count = 1;
sim/simavr/sim/sim_cycle_timers.c:	avr->run_cycle_limit = 1;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_count_t run_cycle_count = ((avr->run_cycle_limit >= sleep_cycle_count) ?
sim/simavr/sim/sim_cycle_timers.c:		sleep_cycle_count : avr->run_cycle_limit);
sim/simavr/sim/sim_cycle_timers.c:	avr->run_cycle_count = run_cycle_count ? run_cycle_count : 1;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:		if(pool->timer->when > avr->cycle) {
sim/simavr/sim/sim_cycle_timers.c:			sleep_cycle_count = pool->timer->when - avr->cycle;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:	when += avr->cycle;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:			return 1 + (t->when - avr->cycle);
sim/simavr/sim/sim_cycle_timers.c:	avr_cycle_timer_pool_t * pool = &avr->cycle_timers;
sim/simavr/sim/sim_cycle_timers.c:		if (when > avr->cycle)
sim/simavr/sim/sim_cycle_timers.c:			return avr_cycle_timer_return_sleep_run_cycles_limited(avr, when - avr->cycle);
sim/simavr/sim/sim_cycle_timers.c:		} while (when && when <= avr->cycle);
sim/simavr/sim/sim_cycle_timers.c:			avr_cycle_timer_insert(avr, when - avr->cycle, t->timer, t->param);
sim/simavr/sim/sim_time.h:	return avr->frequency * (avr_cycle_count_t)usec / 1000000;
sim/simavr/sim/sim_time.h:	return 1000000L * cycles / avr->frequency;
sim/simavr/sim/sim_time.h:	return (uint64_t)1E6 * (uint64_t)cycles / (avr->frequency/1000);
sim/simavr/sim/sim_time.h:	return avr->frequency / hz;
sim/simavr/sim/avr_uart.c:			uint8_t st = avr->data[addr];
sim/simavr/sim/avr_uart.c:			avr->data[addr] = st;
sim/simavr/sim/avr_uart.c:		avr->data[addr] = 0;
sim/simavr/sim/avr_uart.c:				((avr->cycle-p->rxc_raise_time)/p->rx_cnt < p->cycles_per_byte)) {
sim/simavr/sim/avr_uart.c:	avr->data[addr] = v;
sim/simavr/sim/avr_uart.c:	double baud = ((double)avr->frequency) / cycles_per_bit; // can be less than 1
sim/simavr/sim/avr_uart.c:	if (avr->gdb) {
sim/simavr/sim/avr_timer.c:	return p->io.avr->data[p->comp[compi].r_ocr] |
sim/simavr/sim/avr_timer.c:					  (p->io.avr->data[p->comp[compi].r_ocrh] << 8) : 0);
sim/simavr/sim/avr_timer.c:	return avr->data[comp->r_ocr] |
sim/simavr/sim/avr_timer.c:		(ocrh ? (avr->data[ocrh] << 8) : 0);
sim/simavr/sim/avr_timer.c:	return p->io.avr->data[p->r_tcnt] |
sim/simavr/sim/avr_timer.c:				(p->r_tcnth ? (p->io.avr->data[p->r_tcnth] << 8) : 0);
sim/simavr/sim/avr_timer.c:	return p->io.avr->data[p->r_icr] |
sim/simavr/sim/avr_timer.c:				(p->r_tcnth ? (p->io.avr->data[p->r_icrh] << 8) : 0);
sim/simavr/sim/avr_timer.c:				dispatch[compi](avr, avr->cycle, param);
sim/simavr/sim/avr_timer.c:			if (p->comp[compi].comp_cycles < p->tov_cycles && p->comp[compi].comp_cycles >= (avr->cycle - when)) {
sim/simavr/sim/avr_timer.c:					p->comp[compi].comp_cycles - (avr->cycle - next),
sim/simavr/sim/avr_timer.c:			uint64_t when = avr->cycle - p->tov_base;
sim/simavr/sim/avr_timer.c:	avr->data[p->r_tcnt] = tcnt;
sim/simavr/sim/avr_timer.c:		avr->data[p->r_tcnth] = tcnt >> 8;
sim/simavr/sim/avr_timer.c:			avr_timer_tov(avr, avr->cycle - cycles, p);
sim/simavr/sim/avr_timer.c:		//	tcnt = ((avr->cycle - p->tov_base) * p->tov_top) / p->tov_cycles;
sim/simavr/sim/avr_timer.c:			resulting_clock = (float)avr->frequency / prescaler;
sim/simavr/sim/avr_timer.c:			tov_cycles_exact = (float)avr->frequency / p->ext_clock * prescaler * (top+1);
sim/simavr/sim/avr_timer.c:					__FUNCTION__, p->name, ((float)avr->frequency / tov_cycles_exact),
sim/simavr/sim/avr_timer.c:			comp_cycles = (uint32_t)((float)avr->frequency / p->ext_clock * prescaler * (ocr+1));
sim/simavr/sim/avr_timer.c:				avr_timer_tov(avr, avr->cycle, p);
sim/simavr/sim/avr_timer.c:				avr_cycle_timer_register(avr, p->tov_cycles - (avr->cycle - orig_tov_base), avr_timer_tov, p);
sim/simavr/sim/avr_timer.c:				//p->cs_div_value = (uint32_t)((uint64_t)avr->frequency * (1 << p->cs_div[new_cs]) / 32768);
sim/simavr/sim/avr_timer.c:			avr_timer_comp(p, avr->cycle, compi, 0);
sim/simavr/sim/avr_timer.c:	avr->data[p->r_icr] = tcnt;
sim/simavr/sim/avr_timer.c:		avr->data[p->r_icrh] = tcnt >> 8;
sim/simavr/sim/avr_timer.c:				if (new_freq <= port->avr->frequency/4) {
sim/simavr/sim/avr_timer.c:				if (new_freq <= port->avr->frequency/2) {
sim/simavr/sim/avr_twi.c:	uint16_t bitrate =  p->io.avr->data[p->r_twbr];
sim/simavr/sim/avr_twi.c:		if (avr->data[p->r_twar]) {
sim/simavr/sim/avr_twi.c:			AVR_TRACE(avr, "TWEN Slave: %02x&%02x\n", avr->data[p->r_twar] >> 1, avr->data[p->r_twamr] >> 1);
sim/simavr/sim/avr_twi.c:						avr_twi_irq_msg(TWI_COND_READ | TWI_COND_ACK, p->peer_addr, avr->data[p->r_twdr]));
sim/simavr/sim/avr_twi.c:					avr_twi_irq_msg(TWI_COND_ADDR + (do_ack ? TWI_COND_ACK : 0), p->peer_addr, avr->data[p->r_twdr]));
sim/simavr/sim/avr_twi.c:						p->peer_addr, avr->data[p->r_twdr]));
sim/simavr/sim/avr_twi.c:				AVR_TRACE(avr, "I2C WRITE byte %02x to %02x\n", avr->data[p->r_twdr], p->peer_addr);
sim/simavr/sim/avr_twi.c:						avr_twi_irq_msg(msgv, p->peer_addr, avr->data[p->r_twdr]));
sim/simavr/sim/avr_twi.c:			AVR_TRACE(avr, "I2C Master address %02x\n", avr->data[p->r_twdr]);
sim/simavr/sim/avr_twi.c:			p->peer_addr = avr->data[p->r_twdr];
sim/simavr/sim/avr_twi.c:	return avr->data[p->r_twdr];
sim/simavr/sim/avr_twi.c:			uint8_t mask = ~avr->data[p->r_twamr] >> 1;
sim/simavr/sim/avr_twi.c:				msg.u.twi.addr, avr->data[p->r_twar] >> 1, mask);
sim/simavr/sim/avr_twi.c:			if (p->peer_addr == ((avr->data[p->r_twar] >> 1) & mask)) {
sim/simavr/sim/avr_twi.c:			if (avr->data[p->r_twar] & 1) {
sim/simavr/sim/avr_twi.c:			avr->data[p->r_twdr] = msg.u.twi.data;
sim/simavr/sim/avr_twi.c:			avr->data[p->r_twdr] = msg.u.twi.data;
sim/simavr/sim/sim_cmds.c:	avr_cmd_table_t * commands = &avr->commands;
sim/simavr/sim/sim_cmds.c:	avr_cmd_table_t * commands = &avr->commands;
sim/simavr/sim/sim_cmds.c:	avr_cmd_table_t * commands = &avr->commands;
sim/simavr/sim/sim_cmds.c:	if (avr->vcd)
sim/simavr/sim/sim_cmds.c:		avr_vcd_start(avr->vcd);
sim/simavr/sim/sim_cmds.c:	if (avr->vcd)
sim/simavr/sim/sim_cmds.c:		avr_vcd_stop(avr->vcd);
sim/simavr/sim/sim_cmds.c:	memset(&avr->commands, 0, sizeof(avr->commands));
sim/simavr/sim/run_avr.c:	avr->log = (log > LOG_TRACE ? LOG_TRACE : log);
sim/simavr/sim/run_avr.c:	avr->trace = trace;
sim/simavr/sim/run_avr.c:		avr->pc = f.flashbase;
sim/simavr/sim/run_avr.c:		for (int vi = 0; vi < avr->interrupts.vector_count; vi++)
sim/simavr/sim/run_avr.c:			if (avr->interrupts.vector[vi]->vector == trace_vectors[ti])
sim/simavr/sim/run_avr.c:				avr->interrupts.vector[vi]->trace = 1;
sim/simavr/sim/run_avr.c:	avr->gdb_port = port;
sim/simavr/sim/run_avr.c:		avr->state = cpu_Stopped;
sim/simavr/sim/avr_eeprom.c:		ee_addr = avr->data[p->r_eearl] | (avr->data[p->r_eearh] << 8);
sim/simavr/sim/avr_eeprom.c:		ee_addr = avr->data[p->r_eearl];
sim/simavr/sim/avr_eeprom.c:				avr->pc);
sim/simavr/sim/avr_eeprom.c:		//	printf("eeprom write %04x <- %02x\n", addr, avr->data[p->r_eedr]);
sim/simavr/sim/avr_eeprom.c:		p->eeprom[ee_addr] = avr->data[p->r_eedr];
sim/simavr/sim/avr_eeprom.c:		avr->data[p->r_eedr] = p->eeprom[ee_addr];
sim/simavr/sim/avr_usb.c:	return p->io.avr->data[p->r_usbcon + uenum];
sim/simavr/sim/avr_usb.c:	avr->data[p->r_usbcon + ueint] |= 1 << ep;
sim/simavr/sim/avr_usb.c:	uint8_t * Rudien = &p->io.avr->data[p->r_usbcon + udien];
sim/simavr/sim/avr_usb.c:	uint8_t * Rudint = &p->io.avr->data[p->r_usbcon + udint];
sim/simavr/sim/avr_usb.c:	if(avr->data[addr]&1 && !(v&1))
sim/simavr/sim/avr_usb.c:		avr->data[p->r_usbcon + ueint] &= 0xff ^ (1 << ep); // mark ep0 interrupt
sim/simavr/sim/avr_usb.c:	if (avr->data[p->r_usbcon + udcon] & 1)
sim/simavr/sim/avr_usb.c:		p->io.avr->data[p->r_usbcon + i] = 0;
sim/simavr/sim/avr_usb.c:	p->io.avr->data[p->r_usbcon] = 0x20;
sim/simavr/sim/avr_usb.c:	p->io.avr->data[p->r_usbcon + udcon] = 1;
sim/simavr/sim/sim_avr.h: * The current log level is kept in avr->log.
sim/simavr/sim/sim_avr.h: * These are accessors for avr->data but allows watchpoints to be set for gdb
sim/simavr/sim/sim_io.c:	avr_io_t * port = avr->io_port;
sim/simavr/sim/sim_io.c:	io->next = avr->io_port;
sim/simavr/sim/sim_io.c:	avr->io_port = io;
sim/simavr/sim/sim_io.c:	if (avr->io[a].r.param || avr->io[a].r.c) {
sim/simavr/sim/sim_io.c:		if (avr->io[a].r.param != param || avr->io[a].r.c != readp) {
sim/simavr/sim/sim_io.c:					avr->io[a].r.c, avr->io[a].r.param, readp, param);
sim/simavr/sim/sim_io.c:	avr->io[a].r.param = param;
sim/simavr/sim/sim_io.c:	avr->io[a].r.c = readp;
sim/simavr/sim/sim_io.c:	for (int i = 0; i < avr->io_shared_io[io].used; i++) {
sim/simavr/sim/sim_io.c:		avr_io_write_t c = avr->io_shared_io[io].io[i].c;
sim/simavr/sim/sim_io.c:			c(avr, addr, v, avr->io_shared_io[io].io[i].param);
sim/simavr/sim/sim_io.c:	if (avr->io[a].w.param || avr->io[a].w.c) {
sim/simavr/sim/sim_io.c:		if (avr->io[a].w.param != param || avr->io[a].w.c != writep) {
sim/simavr/sim/sim_io.c:			if (avr->io[a].w.c != _avr_io_mux_write) {
sim/simavr/sim/sim_io.c:				int no = avr->io_shared_io_count++;
sim/simavr/sim/sim_io.c:				if (avr->io_shared_io_count > ARRAY_SIZE(avr->io_shared_io)) {
sim/simavr/sim/sim_io.c:				avr->io_shared_io[no].used = 1;
sim/simavr/sim/sim_io.c:				avr->io_shared_io[no].io[0].param = avr->io[a].w.param;
sim/simavr/sim/sim_io.c:				avr->io_shared_io[no].io[0].c = avr->io[a].w.c;
sim/simavr/sim/sim_io.c:				avr->io[a].w.param = (void*)(intptr_t)no;
sim/simavr/sim/sim_io.c:				avr->io[a].w.c = _avr_io_mux_write;
sim/simavr/sim/sim_io.c:			int no = (intptr_t)avr->io[a].w.param;
sim/simavr/sim/sim_io.c:			int d = avr->io_shared_io[no].used++;
sim/simavr/sim/sim_io.c:			if (avr->io_shared_io[no].used > ARRAY_SIZE(avr->io_shared_io[0].io)) {
sim/simavr/sim/sim_io.c:			avr->io_shared_io[no].io[d].param = param;
sim/simavr/sim/sim_io.c:			avr->io_shared_io[no].io[d].c = writep;
sim/simavr/sim/sim_io.c:	avr->io[a].w.param = param;
sim/simavr/sim/sim_io.c:	avr->io[a].w.c = writep;
sim/simavr/sim/sim_io.c:	avr_io_t * port = avr->io_port;
sim/simavr/sim/sim_io.c:	if (avr->io[a].irq == NULL) {
sim/simavr/sim/sim_io.c:		avr->io[a].irq = avr_alloc_irq(&avr->irq_pool, 0, 9, namep);
sim/simavr/sim/sim_io.c:			avr->io[a].irq[i].flags |= IRQ_FLAG_FILTERED;
sim/simavr/sim/sim_io.c:		free((void*)avr->io[a].irq[index].name);
sim/simavr/sim/sim_io.c:		avr->io[a].irq[index].name = strdup(n);
sim/simavr/sim/sim_io.c:	return avr->io[a].irq + index;
sim/simavr/sim/sim_io.c://				strcpy(dst, io->avr->mmcu);
sim/simavr/sim/sim_io.c:		irqs = avr_alloc_irq(&io->avr->irq_pool, 0,
sim/simavr/sim/sim_io.c:	avr_io_t * port = avr->io_port;
sim/simavr/sim/sim_io.c:	avr->io_port = NULL;
sim/simavr/sim/sim_regbit.h:	avr_core_watch_write(avr, a, (uint8_t)(avr->data[a] | m));
sim/simavr/sim/sim_regbit.h:	return (uint8_t)((avr->data[a] >> rb.bit) & rb.mask);
sim/simavr/sim/sim_regbit.h:                             (uint8_t)((avr->data[a] & ~(m)) |
sim/simavr/sim/sim_regbit.h:	return (uint8_t)((avr->data[a] >> rb.bit) & rb.mask);
sim/simavr/sim/sim_regbit.h:                             (uint8_t)((avr->data[a] & ~(m)) | ((v) & m)));
sim/simavr/sim/sim_regbit.h:	return (uint8_t)((avr->data[a]) & (rb.mask << rb.bit));
sim/simavr/sim/sim_regbit.h:	return (uint8_t)((avr->data[a] >> rb.bit) & rb.mask);
sim/simavr/sim/sim_regbit.h:	return (uint8_t)((avr->data[a]) & (rb.mask << rb.bit));
sim/simavr/sim/sim_regbit.h:	avr_core_watch_write(avr, a, (uint8_t)(avr->data[a] & ~m));
sim/simavr/sim/sim_regbit.h:	return avr->data[a];
sim/simavr/sim/sim_regbit.h:		res |= (uint8_t)(((avr->data[a] >> rb->bit) & rb->mask) << i);
sim/simavr/sim/avr_extint.c:	if (avr->sreg[S_I]) {
sim/simavr/sim/avr_extint.c:	avr_io_t * periferal = avr->io_port;
sim/simavr/sim/avr_extint.c:					if (avr->sreg[S_I]) {
sim/simavr/sim/avr_lin.c:	uint32_t lbrr = (avr->data[p->r_linbrrh] << 8) | avr->data[p->r_linbrrl];
sim/simavr/sim/avr_lin.c:	//uint32_t baud = avr->frequency / (lbt * (lbrr + 1));
sim/simavr/sim/avr_lin.c:	double baud = ((double)avr->frequency) / cycles_per_bit; // can be less than 1
sim/simavr/sim/avr_lin.c:	avr->data[p->r_linbtr] = 0x20;
sim/simavr/sim/avr_ioport.c:	uint8_t ddr = avr->data[p->r_ddr];
sim/simavr/sim/avr_ioport.c:	uint8_t v = (avr->data[p->r_pin] & ~ddr) | (avr->data[p->r_port] & ddr);
sim/simavr/sim/avr_ioport.c:	avr->data[addr] = v;
sim/simavr/sim/avr_ioport.c:	D(if (avr->data[addr] != v) printf("** PIN%c(%02x) = %02x\r\n", p->name, addr, v);)
sim/simavr/sim/avr_ioport.c:	uint8_t ddr = avr->data[p->r_ddr];
sim/simavr/sim/avr_ioport.c:			avr_raise_irq(p->io.irq + i, (avr->data[p->r_port] >> i) & 1);
sim/simavr/sim/avr_ioport.c:		else if ((avr->data[p->r_port] >> i) & 1)
sim/simavr/sim/avr_ioport.c:	uint8_t pin = (avr->data[p->r_pin] & ~ddr) | (avr->data[p->r_port] & ddr);
sim/simavr/sim/avr_ioport.c:	if (avr->io[port_io].irq) {
sim/simavr/sim/avr_ioport.c:		avr_raise_irq(avr->io[port_io].irq + AVR_IOMEM_IRQ_ALL, avr->data[p->r_port]);
sim/simavr/sim/avr_ioport.c:			avr_raise_irq(avr->io[port_io].irq + i, (avr->data[p->r_port] >> i) & 1);
sim/simavr/sim/avr_ioport.c:	D(if (avr->data[addr] != v) printf("** PORT%c(%02x) = %02x\r\n", p->name, addr, v);)
sim/simavr/sim/avr_ioport.c:	avr_ioport_write(avr, p->r_port, avr->data[p->r_port] ^ v, param);
sim/simavr/sim/avr_ioport.c:	D(if (avr->data[addr] != v) printf("** DDR%c(%02x) = %02x\r\n", p->name, addr, v);)
sim/simavr/sim/avr_ioport.c:	uint8_t ddr = avr->data[p->r_ddr];
sim/simavr/sim/avr_ioport.c:				 (avr->data[p->r_port] & ~mask) | value,
sim/simavr/sim/avr_ioport.c:							 (avr->data[p->r_pin] & ~mask) | value);
sim/simavr/sim/avr_ioport.c:		int raisedata = avr->data[p->r_pcint];
sim/simavr/sim/avr_ioport.c:					.port = avr->data[p->r_port],
sim/simavr/sim/avr_ioport.c:					.ddr = avr->data[p->r_ddr],
sim/simavr/sim/avr_ioport.c:					.pin = avr->data[p->r_pin],
sim/simavr/sim/avr_ioport.c:		printf("skipping PORT%c for core %s\n", p->name, avr->mmcu);
sim/simavr/sim/sim_avr.c:	if (!avr->time_base)
sim/simavr/sim/sim_avr.c:		avr->time_base = stamp;
sim/simavr/sim/sim_avr.c:	return stamp - avr->time_base;
sim/simavr/sim/sim_avr.c:	avr->flash = malloc(avr->flashend + 4);
sim/simavr/sim/sim_avr.c:	memset(avr->flash, 0xff, avr->flashend + 1);
sim/simavr/sim/sim_avr.c:	*((uint16_t*)&avr->flash[avr->flashend + 1]) = AVR_OVERFLOW_OPCODE;
sim/simavr/sim/sim_avr.c:	avr->codeend = avr->flashend;
sim/simavr/sim/sim_avr.c:	avr->data = malloc(avr->ramend + 1);
sim/simavr/sim/sim_avr.c:	memset(avr->data, 0, avr->ramend + 1);
sim/simavr/sim/sim_avr.c:	avr->trace_data = calloc(1, sizeof(struct avr_trace_data_t));
sim/simavr/sim/sim_avr.c:        avr->trace_data->data_names_size = avr->ioend + 1;
sim/simavr/sim/sim_avr.c:	avr->data_names = calloc(avr->ioend + 1, sizeof (char *));
sim/simavr/sim/sim_avr.c:	for (int i = 0; i < ARRAY_SIZE(avr->serial); i++)
sim/simavr/sim/sim_avr.c:		avr->serial[i] = r >> (i * 3);
sim/simavr/sim/sim_avr.c:	AVR_LOG(avr, LOG_TRACE, "%s init\n", avr->mmcu);
sim/simavr/sim/sim_avr.c:			avr->serial[0], avr->serial[1], avr->serial[2], avr->serial[3],
sim/simavr/sim/sim_avr.c:			avr->serial[4], avr->serial[5], avr->serial[6], avr->serial[7],
sim/simavr/sim/sim_avr.c:			avr->serial[8]);
sim/simavr/sim/sim_avr.c:	avr->state = cpu_Limbo;
sim/simavr/sim/sim_avr.c:	avr->frequency = 1000000;	// can be overridden via avr_mcu_section
sim/simavr/sim/sim_avr.c:	if (avr->custom.init)
sim/simavr/sim/sim_avr.c:		avr->custom.init(avr, avr->custom.data);
sim/simavr/sim/sim_avr.c:	if (avr->init)
sim/simavr/sim/sim_avr.c:		avr->init(avr);
sim/simavr/sim/sim_avr.c:	avr->run = avr_callback_run_raw;
sim/simavr/sim/sim_avr.c:	avr->sleep = avr_callback_sleep_raw;
sim/simavr/sim/sim_avr.c:	avr->address_size = avr->eind ? 3 : 2;
sim/simavr/sim/sim_avr.c:	avr->log = LOG_ERROR;
sim/simavr/sim/sim_avr.c:	avr_regbit_set(avr, avr->reset_flags.porf);		// by  default set to power-on reset
sim/simavr/sim/sim_avr.c:	if (avr->custom.deinit)
sim/simavr/sim/sim_avr.c:		avr->custom.deinit(avr, avr->custom.data);
sim/simavr/sim/sim_avr.c:	if (avr->gdb) {
sim/simavr/sim/sim_avr.c:		avr->gdb = NULL;
sim/simavr/sim/sim_avr.c:	if (avr->vcd) {
sim/simavr/sim/sim_avr.c:		avr_vcd_close(avr->vcd);
sim/simavr/sim/sim_avr.c:		avr->vcd = NULL;
sim/simavr/sim/sim_avr.c:	if (avr->flash) free(avr->flash);
sim/simavr/sim/sim_avr.c:	if (avr->data) free(avr->data);
sim/simavr/sim/sim_avr.c:	if (avr->io_console_buffer.buf) {
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.len = 0;
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.size = 0;
sim/simavr/sim/sim_avr.c:		free(avr->io_console_buffer.buf);
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.buf = NULL;
sim/simavr/sim/sim_avr.c:	avr->flash = avr->data = NULL;
sim/simavr/sim/sim_avr.c:	AVR_LOG(avr, LOG_TRACE, "%s reset\n", avr->mmcu);
sim/simavr/sim/sim_avr.c:	avr->state = cpu_Running;
sim/simavr/sim/sim_avr.c:	for(int i = 0x20; i <= avr->ioend; i++)
sim/simavr/sim/sim_avr.c:		avr->data[i] = 0;
sim/simavr/sim/sim_avr.c:	_avr_sp_set(avr, avr->ramend);
sim/simavr/sim/sim_avr.c:	avr->pc = avr->reset_pc;	// Likely to be zero
sim/simavr/sim/sim_avr.c:		avr->sreg[i] = 0;
sim/simavr/sim/sim_avr.c:	if (avr->reset)
sim/simavr/sim/sim_avr.c:		avr->reset(avr);
sim/simavr/sim/sim_avr.c:	avr_io_t * port = avr->io_port;
sim/simavr/sim/sim_avr.c:	avr->cycle = 0; // Prevent crash
sim/simavr/sim/sim_avr.c:	avr->state = cpu_Stopped;
sim/simavr/sim/sim_avr.c:	if (avr->gdb_port) {
sim/simavr/sim/sim_avr.c:		if (!avr->gdb)
sim/simavr/sim/sim_avr.c:	if (!avr->gdb)
sim/simavr/sim/sim_avr.c:		avr->state = cpu_Crashed;
sim/simavr/sim/sim_avr.c:	if (v == '\r' && avr->io_console_buffer.buf) {
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.buf[avr->io_console_buffer.len] = 0;
sim/simavr/sim/sim_avr.c:			avr->io_console_buffer.buf);
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.len = 0;
sim/simavr/sim/sim_avr.c:	if (avr->io_console_buffer.len + 1 >= avr->io_console_buffer.size) {
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.size += 128;
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.buf = (char*)realloc(
sim/simavr/sim/sim_avr.c:			avr->io_console_buffer.buf,
sim/simavr/sim/sim_avr.c:			avr->io_console_buffer.size);
sim/simavr/sim/sim_avr.c:		avr->io_console_buffer.buf[avr->io_console_buffer.len++] = v;
sim/simavr/sim/sim_avr.c:	if ((address + size) > avr->flashend+1) {
sim/simavr/sim/sim_avr.c:			size, avr->flashend + 1);
sim/simavr/sim/sim_avr.c:	memcpy(avr->flash + address, code, size);
sim/simavr/sim/sim_avr.c:	avr->sleep_usec += avr_cycles_to_usec(avr, howLong);
sim/simavr/sim/sim_avr.c:	uint32_t usec = avr->sleep_usec;
sim/simavr/sim/sim_avr.c:		avr->sleep_usec = 0;
sim/simavr/sim/sim_avr.c:	avr_gdb_processor(avr, avr->state == cpu_Stopped ? 50000 : 0);
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Stopped)
sim/simavr/sim/sim_avr.c:	int step = avr->state == cpu_Step;
sim/simavr/sim/sim_avr.c:		avr->state = cpu_Running;
sim/simavr/sim/sim_avr.c:	avr_flashaddr_t new_pc = avr->pc;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Running) {
sim/simavr/sim/sim_avr.c:	avr->pc = new_pc;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Sleeping) {
sim/simavr/sim/sim_avr.c:		if (!avr->sreg[S_I]) {
sim/simavr/sim/sim_avr.c:			if (avr->log)
sim/simavr/sim/sim_avr.c:			avr->state = cpu_Done;
sim/simavr/sim/sim_avr.c:		avr->sleep(avr, sleep);
sim/simavr/sim/sim_avr.c:		avr->cycle += 1 + sleep;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
sim/simavr/sim/sim_avr.c:		avr->state = cpu_StepDone;
sim/simavr/sim/sim_avr.c:	uint64_t deadline_ns = avr_cycles_to_nsec(avr, avr->cycle + how_long);
sim/simavr/sim/sim_avr.c:	avr_flashaddr_t new_pc = avr->pc;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Running) {
sim/simavr/sim/sim_avr.c:	avr->pc = new_pc;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Sleeping) {
sim/simavr/sim/sim_avr.c:		if (!avr->sreg[S_I]) {
sim/simavr/sim/sim_avr.c:			if (avr->log)
sim/simavr/sim/sim_avr.c:			avr->state = cpu_Done;
sim/simavr/sim/sim_avr.c:		avr->sleep(avr, sleep);
sim/simavr/sim/sim_avr.c:		avr->cycle += 1 + sleep;
sim/simavr/sim/sim_avr.c:	if (avr->state == cpu_Running || avr->state == cpu_Sleeping) {
sim/simavr/sim/sim_avr.c:		if (avr->interrupt_state)
sim/simavr/sim/sim_avr.c:	avr->run(avr);
sim/simavr/sim/sim_avr.c:	return avr->state;
sim/simavr/sim/sim_avr.c:			avr->mmcu, avr->flashend, avr->ramend, avr->e2end);
sim/simavr/sim/sim_avr.c:	if (!avr || avr->log >= level) {
sim/simavr/sim/sim_dwarf.c:    if (symv >= avr->trace_data->codeline_size)
sim/simavr/sim/sim_dwarf.c:    ep = avr->trace_data->codeline + symv;
sim/simavr/sim/sim_dwarf.c:                    symv < avr->trace_data->data_names_size &&
sim/simavr/sim/sim_dwarf.c:                    symv <= avr->ioend &&
sim/simavr/sim/sim_dwarf.c:                        !avr->data_names[symv]) {
sim/simavr/sim/sim_dwarf.c:                        avr->data_names[symv] = strdup(name);
sim/simavr/sim/sim_dwarf.c:            ep = avr->trace_data->codeline + (addr >> 1);
sim/simavr/sim/avr_spi.c:			avr_raise_irq(p->io.irq + SPI_IRQ_OUTPUT, avr->data[p->r_spdr]);
sim/simavr/sim/avr_spi.c:		uint16_t clock_shift = _avr_spi_clkdiv[avr->data[p->r_spcr]&0b11];
sim/simavr/sim/avr_spi.c:		avr_raise_irq(p->io.irq + SPI_IRQ_OUTPUT, avr->data[p->r_spdr]);
sim/simavr/sim/avr_usi.c:	uint8_t counter_val = avr->data[p->r_usisr] & 0xF;
sim/simavr/sim/avr_usi.c:	avr->data[p->r_usisr] &= 0xf0;
sim/simavr/sim/avr_usi.c:	avr->data[p->r_usisr] |= (counter_val & 0x0f);
sim/simavr/sim/avr_usi.c:			avr_core_watch_write(avr, p->r_usibr, avr->data[p->r_usidr]);
sim/simavr/sim/avr_usi.c:		DBG(printf("USI ------------------- 	OVERFLOW! usidr = 0x%02X\n", avr->data[p->r_usidr]));
sim/simavr/sim/avr_usi.c:				  ((p->io.avr->data[p->r_usidr] & 0x80) ? 1 : 0) |
sim/simavr/sim/avr_usi.c:	_avr_usi_set_usidr(avr, p, ((avr->data[p->r_usidr] & ~0x80) << 1) | (p->in_bit0 ? 1 : 0));
sim/simavr/sim/avr_usi.c:		v |= (avr->data[addr] & (1 << p->usipf.bit));
sim/simavr/sim/avr_usi.c:		v |= (avr->data[addr] & (1 << p->usidc.bit));
sim/simavr/sim/avr_usi.c:		p->io.avr->cycle));
sim/simavr/sim/avr_usi.c:		avr->cycle));
sim/simavr/sim/sim_gdb.c:				avr->data[R_SPL], avr->data[R_SPH],
sim/simavr/sim/sim_gdb.c:				avr->pc & 0xff, (avr->pc >> 8) & 0xff,
sim/simavr/sim/sim_gdb.c:				(avr->pc >> 16) & 0xff);
sim/simavr/sim/sim_gdb.c:			g->avr->data[regi] = *src;
sim/simavr/sim/sim_gdb.c:			g->avr->data[R_SREG] = *src;
sim/simavr/sim/sim_gdb.c:			g->avr->data[R_SPL] = src[0];
sim/simavr/sim/sim_gdb.c:			g->avr->data[R_SPH] = src[1];
sim/simavr/sim/sim_gdb.c:			g->avr->pc = src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);
sim/simavr/sim/sim_gdb.c:			sprintf(rep, "%02x", g->avr->data[regi]);
sim/simavr/sim/sim_gdb.c:			sprintf(rep, "%02x%02x", g->avr->data[R_SPL], g->avr->data[R_SPH]);
sim/simavr/sim/sim_gdb.c:				g->avr->pc & 0xff, (g->avr->pc>>8)&0xff, (g->avr->pc>>16)&0xff);
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:				if (count <= 0 || base + count + 32 > avr->ioend) {
sim/simavr/sim/sim_gdb.c:			if (addr + count > avr->ioend)
sim/simavr/sim/sim_gdb.c:				count = avr->ioend + 1 - addr;
sim/simavr/sim/sim_gdb.c:						 name, avr->data[addr + i]);
sim/simavr/sim/sim_gdb.c:			count = g->ior_count ? g->ior_count : avr->ioend - 32 + 1;
sim/simavr/sim/sim_gdb.c:		if (addr < avr->flashend) {
sim/simavr/sim/sim_gdb.c:			src = avr->flash + addr;
sim/simavr/sim/sim_gdb.c:			if (addr + len > avr->flashend)
sim/simavr/sim/sim_gdb.c:				len = avr->flashend - addr;
sim/simavr/sim/sim_gdb.c:			} else if (addr < avr->flashend) {
sim/simavr/sim/sim_gdb.c:				src = avr->flash + addr;
sim/simavr/sim/sim_gdb.c:				limit = avr->flash + avr->flashend;
sim/simavr/sim/sim_gdb.c:						   (src - avr->flash) - addr);)
sim/simavr/sim/sim_gdb.c:				addr = src - avr->flash; // Address of end.
sim/simavr/sim/sim_gdb.c:				if (addr > avr->codeend) // Checked by sim_core.c
sim/simavr/sim/sim_gdb.c:					avr->codeend = addr;
sim/simavr/sim/sim_gdb.c:						g->avr->ramend + 1, g->avr->flashend + 1);
sim/simavr/sim/sim_gdb.c:			if (addr < avr->flashend) {
sim/simavr/sim/sim_gdb.c:				src = avr->flash + addr;
sim/simavr/sim/sim_gdb.c:			} else if (addr >= 0x800000 && (addr - 0x800000) <= avr->ramend) {
sim/simavr/sim/sim_gdb.c:				src = avr->data + addr - 0x800000;
sim/simavr/sim/sim_gdb.c:			} else if (addr == (0x800000 + avr->ramend + 1) && len == 2) {
sim/simavr/sim/sim_gdb.c:			} else if (addr >= 0x810000 && (addr - 0x810000) <= avr->e2end) {
sim/simavr/sim/sim_gdb.c:						addr, len, avr->ramend+1);
sim/simavr/sim/sim_gdb.c:				read_hex_string(start + 1, avr->flash + addr, strlen(start+1));
sim/simavr/sim/sim_gdb.c:			} else if (addr >= 0x800000 && (addr - 0x800000) <= avr->ramend) {
sim/simavr/sim/sim_gdb.c:				read_hex_string(start + 1, avr->data + addr - 0x800000, strlen(start+1));
sim/simavr/sim/sim_gdb.c:			} else if (addr >= 0x810000 && (addr - 0x810000) <= avr->e2end) {
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Running;
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Step;
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:					if (addr > avr->flashend ||
sim/simavr/sim/sim_gdb.c:					if (addr > avr->ramend ||
sim/simavr/sim/sim_gdb.c:			if (avr->state = cpu_Stopped)
sim/simavr/sim/sim_gdb.c:				avr->state = cpu_Running;
sim/simavr/sim/sim_gdb.c:			avr->state = cpu_Done;
sim/simavr/sim/sim_gdb.c:		g->avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:			g->avr->state = cpu_Running;	// resume
sim/simavr/sim/sim_gdb.c:			g->avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:	avr_gdb_t *g = avr->gdb;
sim/simavr/sim/sim_gdb.c:	avr_gdb_t *g = avr->gdb;
sim/simavr/sim/sim_gdb.c:		avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:	if (!avr || !avr->gdb)
sim/simavr/sim/sim_gdb.c:	avr_gdb_t * g = avr->gdb;
sim/simavr/sim/sim_gdb.c:	if (avr->state == cpu_Running &&
sim/simavr/sim/sim_gdb.c:			gdb_watch_find(&g->breakpoints, avr->pc) != -1) {
sim/simavr/sim/sim_gdb.c:		DBG(printf("avr_gdb_processor hit breakpoint at %08x\n", avr->pc);)
sim/simavr/sim/sim_gdb.c:		avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:	} else if (avr->state == cpu_StepDone) {
sim/simavr/sim/sim_gdb.c:		avr->state = cpu_Stopped;
sim/simavr/sim/sim_gdb.c:	if (avr->gdb)
sim/simavr/sim/sim_gdb.c:	avr->gdb = NULL;
sim/simavr/sim/sim_gdb.c:	address.sin_port = htons (avr->gdb_port);
sim/simavr/sim/sim_gdb.c:	printf("avr_gdb_init listening on port %d\n", avr->gdb_port);
sim/simavr/sim/sim_gdb.c:	avr->gdb = g;
sim/simavr/sim/sim_gdb.c:	avr->run = avr_callback_run_gdb;
sim/simavr/sim/sim_gdb.c:	avr->sleep = avr_callback_sleep_gdb;
sim/simavr/sim/sim_gdb.c:	if (!avr->gdb)
sim/simavr/sim/sim_gdb.c:	avr->run = avr_callback_run_raw; // restore normal callbacks
sim/simavr/sim/sim_gdb.c:	avr->sleep = avr_callback_sleep_raw;
sim/simavr/sim/sim_gdb.c:	if (avr->gdb->listen != -1)
sim/simavr/sim/sim_gdb.c:		close(avr->gdb->listen);
sim/simavr/sim/sim_gdb.c:	avr->gdb->listen = -1;
sim/simavr/sim/sim_gdb.c:	if (avr->gdb->s != -1)
sim/simavr/sim/sim_gdb.c:		close(avr->gdb->s);
sim/simavr/sim/sim_gdb.c:	avr->gdb->s = -1;
sim/simavr/sim/sim_gdb.c:	free(avr->gdb);
sim/simavr/sim/sim_gdb.c:	avr->gdb = NULL;
sim/simavr/sim/sim_vcd_file.c:		avr->state = cpu_Done;
sim/simavr/sim/sim_vcd_file.c:	next = (log.when * avr->frequency) / (1000*1000*1000);
sim/simavr/sim/sim_vcd_file.c:			when = (vcd->period * vcd->avr->frequency) /
sim/simavr/sim/sim_vcd_file.c:		.when = vcd->avr->cycle,
sim/simavr/sim/sim_vcd_file.c:	avr_init_irq(&vcd->avr->irq_pool, &s->irq, index, 1, names);
sim/simavr/sim/sim_vcd_file.c:	vcd->start = vcd->avr->cycle;
sim/simavr/sim/sim_core.c:	pc = avr->pc >> 1; // Words
sim/simavr/sim/sim_core.c:	if (avr->trace_data->codeline &&
sim/simavr/sim/sim_core.c:		pc < avr->trace_data->codeline_size) {
sim/simavr/sim/sim_core.c:		s = avr->trace_data->codeline[pc];
sim/simavr/sim/sim_core.c:#define STATE(_f, argsf ...)	if (avr->trace) {				\
sim/simavr/sim/sim_core.c:		printf("%04x: %-25s " _f, avr->pc, symn, ## argsf);	\
sim/simavr/sim/sim_core.c:#define SREG() if (avr->trace && donttrace == 0) {	  \
sim/simavr/sim/sim_core.c:	printf("%04x: \t\t\t\t\t\t\t\tSREG = ", avr->pc); \
sim/simavr/sim/sim_core.c:		printf("%c", avr->sreg[_sbi] ? toupper(_sreg_bit_name[_sbi]) : '.');\
sim/simavr/sim/sim_core.c:	if (addr <= avr->ioend) {
sim/simavr/sim/sim_core.c:	} else if (addr < avr->trace_data->data_names_size) {
sim/simavr/sim/sim_core.c:		return avr->data_names[addr];
sim/simavr/sim/sim_core.c:#define FAS(addr) (((addr >> 1) > avr->trace_data->codeline_size) ? \
sim/simavr/sim/sim_core.c:                   "[not loaded]" : avr->trace_data->codeline[addr >> 1])
sim/simavr/sim/sim_core.c:	printf("*** CYCLE %" PRI_avr_cycle_count " PC %04x\n", avr->cycle, avr->pc);
sim/simavr/sim/sim_core.c:		int pci = (avr->trace_data->old_pci + i) & 0xf;
sim/simavr/sim/sim_core.c:                       avr->trace_data->old[pci].pc,
sim/simavr/sim/sim_core.c:                       avr->trace_data->codeline ?
sim/simavr/sim/sim_core.c:                           avr->trace_data->codeline[avr->trace_data->old[pci].pc>>1] :
sim/simavr/sim/sim_core.c:                       avr->trace_data->old[pci].sp);
sim/simavr/sim/sim_core.c:	printf("Stack Ptr %04x/%04x = %d \n", _avr_sp_get(avr), avr->ramend, avr->ramend - _avr_sp_get(avr));
sim/simavr/sim/sim_core.c:	return(avr->flash[addr] | (avr->flash[addr + 1] << 8));
sim/simavr/sim/sim_core.c:		if (avr->io[io].irq) {
sim/simavr/sim/sim_core.c:			uint8_t v = avr->data[addr];
sim/simavr/sim/sim_core.c:			avr_raise_irq(avr->io[io].irq + AVR_IOMEM_IRQ_ALL, v);
sim/simavr/sim/sim_core.c:				avr_raise_irq(avr->io[io].irq + i, (v >> i) & 1);
sim/simavr/sim/sim_core.c:	if (addr > avr->ramend) {
sim/simavr/sim/sim_core.c:				avr->pc, _avr_sp_get(avr), _avr_flash_read16le(avr, avr->pc), v, addr, (avr->ramend + 1), addr % (avr->ramend + 1));
sim/simavr/sim/sim_core.c:		addr = addr % (avr->ramend + 1);
sim/simavr/sim/sim_core.c:				avr->pc, _avr_sp_get(avr), _avr_flash_read16le(avr, avr->pc), addr, v);
sim/simavr/sim/sim_core.c:	if (avr->trace_data->stack_frame_index > 1 && addr > avr->trace_data->stack_frame[avr->trace_data->stack_frame_index-2].sp) {
sim/simavr/sim/sim_core.c:				avr->pc, _avr_sp_get(avr), addr, v);
sim/simavr/sim/sim_core.c:	if (avr->gdb) {
sim/simavr/sim/sim_core.c:	avr->data[addr] = v;
sim/simavr/sim/sim_core.c:	if (addr > avr->ramend) {
sim/simavr/sim/sim_core.c:				avr->pc, _avr_sp_get(avr), _avr_flash_read16le(avr, avr->pc),
sim/simavr/sim/sim_core.c:				addr, (avr->ramend + 1), addr % (avr->ramend + 1));
sim/simavr/sim/sim_core.c:		addr = addr % (avr->ramend + 1);
sim/simavr/sim/sim_core.c:	if (avr->gdb) {
sim/simavr/sim/sim_core.c:	return avr->data[addr];
sim/simavr/sim/sim_core.c:		avr->data[R_SREG] = v;
sim/simavr/sim/sim_core.c:		if (avr->io[io].w.c) {
sim/simavr/sim/sim_core.c:			avr->io[io].w.c(avr, r, v, avr->io[io].w.param);
sim/simavr/sim/sim_core.c:			avr->data[r] = v;
sim/simavr/sim/sim_core.c:			if (avr->io[io].irq) {
sim/simavr/sim/sim_core.c:				avr_raise_irq(avr->io[io].irq + AVR_IOMEM_IRQ_ALL, v);
sim/simavr/sim/sim_core.c:					avr_raise_irq(avr->io[io].irq + i, (v >> i) & 1);
sim/simavr/sim/sim_core.c:		avr->data[r] = v;
sim/simavr/sim/sim_core.c:	return avr->data[R_SPL] | (avr->data[R_SPH] << 8);
sim/simavr/sim/sim_core.c:	if (addr <= avr->ioend)
sim/simavr/sim/sim_core.c:		READ_SREG_INTO(avr, avr->data[R_SREG]);
sim/simavr/sim/sim_core.c:		if (avr->io[io].r.c)
sim/simavr/sim/sim_core.c:			avr->data[addr] = avr->io[io].r.c(avr, addr, avr->io[io].r.param);
sim/simavr/sim/sim_core.c:		if (avr->io[io].irq) {
sim/simavr/sim/sim_core.c:			uint8_t v = avr->data[addr];
sim/simavr/sim/sim_core.c:			avr_raise_irq(avr->io[io].irq + AVR_IOMEM_IRQ_ALL, v);
sim/simavr/sim/sim_core.c:				avr_raise_irq(avr->io[io].irq + i, (v >> i) & 1);
sim/simavr/sim/sim_core.c:	for (int i = 0; i < avr->address_size; i++, addr >>= 8, sp--) {
sim/simavr/sim/sim_core.c:	return avr->address_size;
sim/simavr/sim/sim_core.c:	for (int i = 0; i < avr->address_size; i++, sp++) {
sim/simavr/sim/sim_core.c:        if (reg > avr->ioend)
sim/simavr/sim/sim_core.c:	if (!avr->data_names[reg]) {
sim/simavr/sim/sim_core.c:		avr->data_names[reg] = strdup(tt);
sim/simavr/sim/sim_core.c:	return avr->data_names[reg];
sim/simavr/sim/sim_core.c:                avr->pc,
sim/simavr/sim/sim_core.c:                avr->trace_data->codeline[avr->pc>>1],
sim/simavr/sim/sim_core.c:                _avr_flash_read16le(avr, avr->pc));
sim/simavr/sim/sim_core.c:			avr->pc, _avr_sp_get(avr), _avr_flash_read16le(avr, avr->pc));
sim/simavr/sim/sim_core.c:	if (!avr->trace || donttrace)
sim/simavr/sim/sim_core.c:		if (avr->trace_data->touched[r])
sim/simavr/sim/sim_core.c:			printf("%s=%02x ", AVR_REGNAME(i), avr->data[i]);
sim/simavr/sim/sim_core.c:		const uint8_t vd = avr->data[d];
sim/simavr/sim/sim_core.c:		const uint8_t vd = avr->data[d], vr = avr->data[r];
sim/simavr/sim/sim_core.c:		const uint8_t vr = avr->data[r];
sim/simavr/sim/sim_core.c:		const uint8_t vh = avr->data[h];
sim/simavr/sim/sim_core.c:		const uint16_t vp = avr->data[p] | (avr->data[p + 1] << 8);
sim/simavr/sim/sim_core.c:	avr->trace_data->old[avr->trace_data->old_pci].pc = avr->pc;\
sim/simavr/sim/sim_core.c:	avr->trace_data->old[avr->trace_data->old_pci].sp = _avr_sp_get(avr);\
sim/simavr/sim/sim_core.c:	avr->trace_data->old_pci = (avr->trace_data->old_pci + 1) & (OLD_PC_SIZE-1);\
sim/simavr/sim/sim_core.c:	avr->trace_data->stack_frame[avr->trace_data->stack_frame_index].pc = avr->pc;\
sim/simavr/sim/sim_core.c:	avr->trace_data->stack_frame[avr->trace_data->stack_frame_index].sp = _avr_sp_get(avr);\
sim/simavr/sim/sim_core.c:	avr->trace_data->stack_frame_index++;
sim/simavr/sim/sim_core.c:	if (avr->trace_data->stack_frame_index > 0) \
sim/simavr/sim/sim_core.c:		avr->trace_data->stack_frame_index--;
sim/simavr/sim/sim_core.c:	avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:	avr->sreg[S_N] = (res >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_S] = avr->sreg[S_N] ^ avr->sreg[S_V];
sim/simavr/sim/sim_core.c:	avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:	avr->sreg[S_N] = (res >> 15) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_S] = avr->sreg[S_N] ^ avr->sreg[S_V];
sim/simavr/sim/sim_core.c:	avr->sreg[S_H] = (add_carry >> 3) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_C] = (add_carry >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = (((rd & rr & ~res) | (~rd & ~rr & res)) >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_H] = (sub_carry >> 3) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_C] = (sub_carry >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = (((rd & ~rr & ~res) | (~rd & rr & res)) >> 7) & 1;
sim/simavr/sim/sim_core.c:		avr->sreg[S_Z] = 0;
sim/simavr/sim/sim_core.c:	avr->sreg[S_N] = (res >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_S] = avr->sreg[S_N] ^ avr->sreg[S_V];
sim/simavr/sim/sim_core.c:	avr->sreg[S_H] = (sub_carry >> 3) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_C] = (sub_carry >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = (((rd & ~rr & ~res) | (~rd & rr & res)) >> 7) & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:	avr->sreg[S_C] = vr & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = avr->sreg[S_N] ^ avr->sreg[S_C];
sim/simavr/sim/sim_core.c:	avr->sreg[S_S] = avr->sreg[S_N] ^ avr->sreg[S_V];
sim/simavr/sim/sim_core.c:	avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:	avr->sreg[S_C] = vr & 1;
sim/simavr/sim/sim_core.c:	avr->sreg[S_N] = res >> 7;
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = avr->sreg[S_N] ^ avr->sreg[S_C];
sim/simavr/sim/sim_core.c:	avr->sreg[S_S] = avr->sreg[S_N] ^ avr->sreg[S_V];
sim/simavr/sim/sim_core.c:	avr->sreg[S_V] = 0;
sim/simavr/sim/sim_core.c:	if ((avr->pc == 0 && avr->cycle > 0) || avr->pc >= avr->codeend ||
sim/simavr/sim/sim_core.c:		_avr_sp_get(avr) > avr->ramend) {
sim/simavr/sim/sim_core.c://		avr->trace = 1;
sim/simavr/sim/sim_core.c://		printf("Bad: %d %d %d %x\n", (avr->pc == 0 && avr->cycle > 0),
sim/simavr/sim/sim_core.c://		avr->pc >= avr->codeend, _avr_sp_get(avr) > avr->ramend, avr->pc);
sim/simavr/sim/sim_core.c:	avr->trace_data->touched[0] = avr->trace_data->touched[1] =
sim/simavr/sim/sim_core.c:		avr->trace_data->touched[2] = 0;
sim/simavr/sim/sim_core.c:	if (unlikely(avr->pc >= avr->flashend)) {
sim/simavr/sim/sim_core.c:	uint32_t		opcode = _avr_flash_read16le(avr, avr->pc);
sim/simavr/sim/sim_core.c:	avr_flashaddr_t	new_pc = avr->pc + 2;	// future "default" pc
sim/simavr/sim/sim_core.c:							uint8_t res = vd - vr - avr->sreg[S_C];
sim/simavr/sim/sim_core.c:							uint8_t res = vd - vr - avr->sreg[S_C];
sim/simavr/sim/sim_core.c:							STATE("sbc %s[%02x], %s[%02x] = %02x\n", AVR_REGNAME(d), avr->data[d], AVR_REGNAME(r), avr->data[r], res);
sim/simavr/sim/sim_core.c:									STATE("movw %s:%s, %s:%s[%02x%02x]\n", AVR_REGNAME(d), AVR_REGNAME(d+1), AVR_REGNAME(r), AVR_REGNAME(r+1), avr->data[r+1], avr->data[r]);
sim/simavr/sim/sim_core.c:									uint16_t vr = avr->data[r] | (avr->data[r + 1] << 8);
sim/simavr/sim/sim_core.c:									int16_t res = ((int8_t)avr->data[r]) * ((int8_t)avr->data[d]);
sim/simavr/sim/sim_core.c:									STATE("muls %s[%d], %s[%02x] = %d\n", AVR_REGNAME(d), ((int8_t)avr->data[d]), AVR_REGNAME(r), ((int8_t)avr->data[r]), res);
sim/simavr/sim/sim_core.c:									avr->sreg[S_C] = (res >> 15) & 1;
sim/simavr/sim/sim_core.c:									avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:											res = ((uint8_t)avr->data[r]) * ((int8_t)avr->data[d]);
sim/simavr/sim/sim_core.c:											res = ((uint8_t)avr->data[r]) * ((uint8_t)avr->data[d]);
sim/simavr/sim/sim_core.c:											res = ((int8_t)avr->data[r]) * ((int8_t)avr->data[d]);
sim/simavr/sim/sim_core.c:											res = ((uint8_t)avr->data[r]) * ((int8_t)avr->data[d]);
sim/simavr/sim/sim_core.c:									STATE("%s %s[%d], %s[%02x] = %d\n", name, AVR_REGNAME(d), ((int8_t)avr->data[d]), AVR_REGNAME(r), ((int8_t)avr->data[r]), res);
sim/simavr/sim/sim_core.c:									avr->sreg[S_C] = c;
sim/simavr/sim/sim_core.c:									avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:					STATE("cpse %s[%02x], %s[%02x]\t; Will%s skip\n", AVR_REGNAME(d), avr->data[d], AVR_REGNAME(r), avr->data[r], res ? "":" not");
sim/simavr/sim/sim_core.c:					uint8_t res = vd + vr + avr->sreg[S_C];
sim/simavr/sim/sim_core.c:						STATE("rol %s[%02x] = %02x\n", AVR_REGNAME(d), avr->data[d], res);
sim/simavr/sim/sim_core.c:						STATE("addc %s[%02x], %s[%02x] = %02x\n", AVR_REGNAME(d), avr->data[d], AVR_REGNAME(r), avr->data[r], res);
sim/simavr/sim/sim_core.c:						STATE("tst %s[%02x]\n", AVR_REGNAME(d), avr->data[d]);
sim/simavr/sim/sim_core.c:						STATE("clr %s[%02x]\n", AVR_REGNAME(d), avr->data[d]);
sim/simavr/sim/sim_core.c:			uint8_t res = vh - k - avr->sreg[S_C];
sim/simavr/sim/sim_core.c:					uint16_t v = avr->data[R_ZL] | (avr->data[R_ZH] << 8);
sim/simavr/sim/sim_core.c:						      q, v+q, AVR_REGNAME(d), avr->data[d], DAS(v + q));
sim/simavr/sim/sim_core.c:						_avr_set_ram(avr, v+q, avr->data[d]);
sim/simavr/sim/sim_core.c:						      AVR_REGNAME(d), q, v+q, avr->data[v+q], DAS(v + q));
sim/simavr/sim/sim_core.c:					uint16_t v = avr->data[R_YL] | (avr->data[R_YH] << 8);
sim/simavr/sim/sim_core.c:						      q, v+q, AVR_REGNAME(d), avr->data[d], DAS(v + q));
sim/simavr/sim/sim_core.c:						_avr_set_ram(avr, v+q, avr->data[d]);
sim/simavr/sim/sim_core.c:						      AVR_REGNAME(d), q, v+q, avr->data[d+q], DAS(v + q));
sim/simavr/sim/sim_core.c:					if (!avr_has_pending_interrupts(avr) || !avr->sreg[S_I])
sim/simavr/sim/sim_core.c:						avr->state = cpu_Sleeping;
sim/simavr/sim/sim_core.c:					if (avr->gdb) {
sim/simavr/sim/sim_core.c:						avr->state = cpu_Stopped;
sim/simavr/sim/sim_core.c:					if (e && !avr->eind)
sim/simavr/sim/sim_core.c:					uint32_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8);
sim/simavr/sim/sim_core.c:						z |= avr->data[avr->eind] << 16;
sim/simavr/sim/sim_core.c:					cycle += 1 + avr->address_size;
sim/simavr/sim/sim_core.c:					uint16_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8);
sim/simavr/sim/sim_core.c:					uint8_t v = avr->flash[z];
sim/simavr/sim/sim_core.c:					if (!avr->rampz)
sim/simavr/sim/sim_core.c:					uint32_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8) | (avr->data[avr->rampz] << 16);
sim/simavr/sim/sim_core.c:					uint8_t v = avr->flash[z];
sim/simavr/sim/sim_core.c:							      AVR_REGNAME(d), avr->data[d], x, DAS(x));
sim/simavr/sim/sim_core.c:							uint16_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8);
sim/simavr/sim/sim_core.c:							uint8_t v = avr->flash[z];
sim/simavr/sim/sim_core.c:							if (!avr->rampz)
sim/simavr/sim/sim_core.c:							uint32_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8) | (avr->data[avr->rampz] << 16);
sim/simavr/sim/sim_core.c:							uint8_t v = avr->flash[z];
sim/simavr/sim/sim_core.c:								_avr_set_r(avr, avr->rampz, z >> 16);
sim/simavr/sim/sim_core.c:							uint16_t x = (avr->data[R_XH] << 8) | avr->data[R_XL];
sim/simavr/sim/sim_core.c:							uint16_t x = (avr->data[R_XH] << 8) | avr->data[R_XL];
sim/simavr/sim/sim_core.c:							uint16_t y = (avr->data[R_YH] << 8) | avr->data[R_YL];
sim/simavr/sim/sim_core.c:							uint16_t y = (avr->data[R_YH] << 8) | avr->data[R_YL];
sim/simavr/sim/sim_core.c:							uint16_t z = (avr->data[R_ZH] << 8) | avr->data[R_ZL];
sim/simavr/sim/sim_core.c:							uint16_t z = (avr->data[R_ZH] << 8) | avr->data[R_ZL];
sim/simavr/sim/sim_core.c:							STATE("pop %s (@%04x)[%02x]\n", AVR_REGNAME(d), sp, avr->data[sp]);
sim/simavr/sim/sim_core.c:							avr->sreg[S_C] = 1;
sim/simavr/sim/sim_core.c:							avr->sreg[S_H] = ((res >> 3) | (vd >> 3)) & 1;
sim/simavr/sim/sim_core.c:							avr->sreg[S_V] = res == 0x80;
sim/simavr/sim/sim_core.c:							avr->sreg[S_C] = res != 0;
sim/simavr/sim/sim_core.c:							avr->sreg[S_V] = res == 0x80;
sim/simavr/sim/sim_core.c:							avr->sreg[S_N] = 0;
sim/simavr/sim/sim_core.c:							uint8_t res = (avr->sreg[S_C] ? 0x80 : 0) | vd >> 1;
sim/simavr/sim/sim_core.c:							avr->sreg[S_V] = res == 0x7f;
sim/simavr/sim/sim_core.c:									avr->sreg[S_V] = ((~vp & res) >> 15) & 1;
sim/simavr/sim/sim_core.c:									avr->sreg[S_C] = ((~res & vp) >> 15) & 1;
sim/simavr/sim/sim_core.c:									avr->sreg[S_V] = ((vp & ~res) >> 15) & 1;
sim/simavr/sim/sim_core.c:									avr->sreg[S_C] = ((res & ~vp) >> 15) & 1;
sim/simavr/sim/sim_core.c:									STATE("cbi %s[%04x], 0x%02x = %02x\n", AVR_REGNAME(io), avr->data[io], mask, res);
sim/simavr/sim/sim_core.c:									STATE("sbic %s[%04x], 0x%02x\t; Will%s branch\n", AVR_REGNAME(io), avr->data[io], mask, !res?"":" not");
sim/simavr/sim/sim_core.c:									STATE("sbi %s[%04x], 0x%02x = %02x\n", AVR_REGNAME(io), avr->data[io], mask, res);
sim/simavr/sim/sim_core.c:									STATE("sbis %s[%04x], 0x%02x\t; Will%s branch\n", AVR_REGNAME(io), avr->data[io], mask, res?"":" not");
sim/simavr/sim/sim_core.c:											avr->sreg[S_Z] = res == 0;
sim/simavr/sim/sim_core.c:											avr->sreg[S_C] = (res >> 15) & 1;
sim/simavr/sim/sim_core.c:					STATE("out %s, %s[%02x]\n", AVR_REGNAME(A), AVR_REGNAME(d), avr->data[d]);
sim/simavr/sim/sim_core.c:					_avr_set_ram(avr, A, avr->data[d]);
sim/simavr/sim/sim_core.c:					STATE("in %s, %s[%02x]\n", AVR_REGNAME(d), AVR_REGNAME(A), avr->data[A]);
sim/simavr/sim/sim_core.c:			new_pc = (new_pc + o) % (avr->flashend+1);
sim/simavr/sim/sim_core.c:			new_pc = (new_pc + o) % (avr->flashend+1);
sim/simavr/sim/sim_core.c:					int branch = (avr->sreg[s] && set) || (!avr->sreg[s] && !set);
sim/simavr/sim/sim_core.c:					uint8_t v = (vd & ~mask) | (avr->sreg[S_T] ? mask : 0);
sim/simavr/sim/sim_core.c:					avr->sreg[S_T] = (vd >> s) & 1;
sim/simavr/sim/sim_core.c:	avr->cycle += cycle;
sim/simavr/sim/sim_core.c:	if ((avr->state == cpu_Running) &&
sim/simavr/sim/sim_core.c:		(avr->run_cycle_count > cycle) &&
sim/simavr/sim/sim_core.c:		(avr->interrupt_state == 0))
sim/simavr/sim/sim_core.c:		avr->run_cycle_count -= cycle;
sim/simavr/sim/sim_core.c:		avr->pc = new_pc;
sim/simavr/sim/sim_elf.c:		avr->frequency = firmware->frequency;
sim/simavr/sim/sim_elf.c:		avr->vcc = firmware->vcc;
sim/simavr/sim/sim_elf.c:		avr->avcc = firmware->avcc;
sim/simavr/sim/sim_elf.c:		avr->aref = firmware->aref;
sim/simavr/sim/sim_elf.c:	avr->trace_data->codeline = table;
sim/simavr/sim/sim_elf.c:	avr->trace_data->codeline_size = scount;
sim/simavr/sim/sim_elf.c:	if (firmware->highest_data_symbol >= avr->trace_data->data_names_size) {
sim/simavr/sim/sim_elf.c:		avr->data_names = realloc(avr->data_names, new_size * sizeof (char *));
sim/simavr/sim/sim_elf.c:		memset(avr->data_names + avr->trace_data->data_names_size,
sim/simavr/sim/sim_elf.c:		       (new_size - avr->trace_data->data_names_size) *
sim/simavr/sim/sim_elf.c:		avr->trace_data->data_names_size = new_size;
sim/simavr/sim/sim_elf.c:                           	  avr->trace_data->data_names_size) {
sim/simavr/sim/sim_elf.c:			sp = &avr->data_names[addr];
sim/simavr/sim/sim_elf.c:	avr_spread_lines(avr->data_names + avr->ioend + 1,
sim/simavr/sim/sim_elf.c:			 avr->trace_data->data_names_size - (avr->ioend + 1));
sim/simavr/sim/sim_elf.c:	avr->codeend = firmware->flashsize +
sim/simavr/sim/sim_elf.c:		memcpy(avr->fuse, firmware->fuse, firmware->fusesize);
sim/simavr/sim/sim_elf.c:		avr->lockbits = firmware->lockbits[0];
sim/simavr/sim/sim_elf.c:	avr->vcd = malloc(sizeof(*avr->vcd));
sim/simavr/sim/sim_elf.c:	memset(avr->vcd, 0, sizeof(*avr->vcd));
sim/simavr/sim/sim_elf.c:		avr->vcd,
sim/simavr/sim/sim_elf.c:			avr->vcd->filename);
sim/simavr/sim/sim_elf.c:				avr_vcd_add_signal(avr->vcd, irq, 1,
sim/simavr/sim/sim_elf.c:				avr_vcd_add_signal(avr->vcd,
sim/simavr/sim/sim_elf.c:				avr_vcd_add_signal(avr->vcd, all, 8,
sim/simavr/sim/sim_elf.c:						avr_vcd_add_signal(avr->vcd,
sim/simavr/sim/sim_elf.c:					avr_vcd_add_signal(avr->vcd, bit, 1, comp);
sim/simavr/sim/sim_elf.c:		avr_vcd_start(avr->vcd);
sim/simavr/sim/sim_elf.c:		//	avr->frequency = f_cpu;
sim/simavr/sim/avr_flash.c:	avr_flashaddr_t z = avr->data[R_ZL] | (avr->data[R_ZH] << 8);
sim/simavr/sim/avr_flash.c:	if (avr->rampz)
sim/simavr/sim/avr_flash.c:		z |= avr->data[avr->rampz] << 16;
sim/simavr/sim/avr_flash.c:			__func__, (char*)&ctl, avr->data[p->r_spm], z,
sim/simavr/sim/avr_flash.c:						case 0x0: *res = avr->fuse[0]; break; // LFuse
sim/simavr/sim/avr_flash.c:						case 0x1: *res = avr->lockbits; break; // lock bits
sim/simavr/sim/avr_flash.c:						case 0x2: *res = avr->fuse[2]; break; // EFuse
sim/simavr/sim/avr_flash.c:						case 0x3: *res = avr->fuse[1]; break; // HFuse
sim/simavr/sim/avr_flash.c:						case 0x00: *res = avr->signature[0]; break;
sim/simavr/sim/avr_flash.c:						case 0x02: *res = avr->signature[1]; break;
sim/simavr/sim/avr_flash.c:						case 0x04: *res = avr->signature[2]; break;
sim/simavr/sim/avr_flash.c:							*res = avr->serial[idx[z]]; break;
sim/simavr/sim/avr_flash.c:			uint16_t r01 = avr->data[0] | (avr->data[1] << 8);
sim/simavr/sim/avr_flash.c:		//	printf("AVR_IOCTL_FLASH_SPM %02x Z:%04x R01:%04x\n", avr->data[p->r_spm], z,r01);
sim/simavr/sim/avr_flash.c:						avr->flash[z++] = 0xff;
sim/simavr/sim/avr_flash.c:						avr->flash[z++] = p->tmppage[i];
sim/simavr/sim/avr_flash.c:						avr->flash[z++] = p->tmppage[i] >> 8;
sim/simavr/sim/sim_core.h:		printf("%s=%02x%c", AVR_REGNAME(i), avr->data[i], \
sim/simavr/sim/sim_core.h:	uint16_t y = avr->data[R_YL] | (avr->data[R_YH] << 8); \
sim/simavr/sim/sim_core.h:		printf("Y+%02d=%02x%c", i, avr->data[y+i], i % 10 == 9 ? '\n' : ' '); \
sim/simavr/sim/sim_core.h:		for (int i = avr->trace_data->stack_frame_index; i; i--) {\
sim/simavr/sim/sim_core.h:					avr->trace_data->stack_frame[pci].pc, \
sim/simavr/sim/sim_core.h:					avr->trace_data->codeline ? avr->trace_data->codeline[avr->trace_data->stack_frame[pci].pc>>1]->symbol : "unknown", \
sim/simavr/sim/sim_core.h:							avr->trace_data->stack_frame[pci].sp);\
sim/simavr/sim/sim_core.h: * Reconstructs the SREG value from avr->sreg into dst.
sim/simavr/sim/sim_core.h:				if (avr->sreg[i] > 1) { \
sim/simavr/sim/sim_core.h:				} else if (avr->sreg[i]) \
sim/simavr/sim/sim_core.h:			if (!avr->sreg[S_I])
sim/simavr/sim/sim_core.h:				avr->interrupt_state = -1;
sim/simavr/sim/sim_core.h:			avr->interrupt_state = 0;
sim/simavr/sim/sim_core.h:	avr->sreg[flag] = ival;
sim/simavr/sim/sim_core.h: * Splits the SREG value from src into the avr->sreg array.
sim/simavr/sim/avr_watchdog.c:		p->reset_context.avr_run = avr->run;
sim/simavr/sim/avr_watchdog.c:		avr->run = avr_watchdog_run_callback_software_reset;
sim/simavr/sim/avr_watchdog.c:	p->cycle_count = (p->cycle_count * avr->frequency) / 128000;
sim/simavr/sim/avr_watchdog.c:	uint8_t old_v = avr->data[addr]; // allow gdb to see write...
sim/simavr/sim/avr_watchdog.c:		avr->data[addr] = old_v;
sim/simavr/sim/avr_watchdog.c:		avr->run = p->reset_context.avr_run;
sim/simavr/cores/sim_mega324.c:/* borken avr-libc missing these declarations :/ */
sim/simavr/cores/sim_core_declare.h: * toolchain and avr-libc. This affects a lot of names, like MCUSR etc
sim/simavr/cores/sim_mega128rfr2.c: * Temporary hack for mangled avr-libc headers
sim/simavr/cores/avr/iotn84.h:/* keep misspelled names from avr-libc 1.4.[0..1] for compatibility */
sim/simavr/cores/avr/ioavr128da28.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/ioavr128da28.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox64a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox384d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox384d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128b1.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128b1.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iotn44.h:/* keep misspelled names from avr-libc 1.4.[0..1] for compatibility */
sim/simavr/cores/avr/iox128c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox384c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox384c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom4809.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom4809.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox256a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox192c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox192c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom1608.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom1608.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/ioavr128da64.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/ioavr128da64.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox8e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox8e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iotnx4.h:/* keep misspelled names from avr-libc 1.4.[0..1] for compatibility */
sim/simavr/cores/avr/iox128a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox192a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox192a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom1609.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom1609.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox192d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox192d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom328p.h:		     * avr-libc versions; not an official name */
sim/simavr/cores/avr/iox64b1.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64b1.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/ioavr128da48.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/ioavr128da48.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox128a1u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128a1u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/ioavr128da32.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/ioavr128da32.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox64a1u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64a1u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iotn24.h:/* keep misspelled names from avr-libc 1.4.[0..1] for compatibility */
sim/simavr/cores/avr/iox128b3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128b3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64b3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64b3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16e5.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256a3bu.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256a3bu.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox128d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16c4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16c4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom4808.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom4808.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iom3208.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom3208.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox64a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox64a3u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16d4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256c3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox16a4u.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox256d3.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iom3209.h:/* avr-libc typedef for avr/fuse.h */
sim/simavr/cores/avr/iom3209.h:/* Added MAPPED_EEPROM segment names for avr-libc */
sim/simavr/cores/avr/iox32c4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/avr/iox32c4.h:    register8_t LOCK_BITS;  /* Lock Bits (Changed from LOCKBITS to avoid avr-libc collision) */
sim/simavr/cores/sim_megaxm1.c:	avr->data[ mcu->lin.r_linbtr] = 0x20;
sim/simavr/Makefile:		simavr-avr.pc >$(DESTDIR)/lib/pkgconfig/simavr-avr.pc
sim/simavr/Makefile:	rm -rf /tmp/simavr-tmp && mkdir -p /tmp/simavr-tmp/usr && \
sim/simavr/Makefile:	make cleam; make install DESTDIR=/tmp/simavr-tmp/usr RELEASE=1 && \
sim/simavr/Makefile:	(cd /tmp/simavr-tmp && \
sim/simavr/Makefile:	fpm -s dir -t deb -C /tmp/simavr-tmp -n libsimavr -v $(SIMAVR_VERSION) \
sim/simavr/Makefile:	fpm -s dir -t deb -C /tmp/simavr-tmp -n libsimavr-dev -v $(SIMAVR_VERSION) \
sim/simavr/Makefile:	fpm -s dir -t deb -C /tmp/simavr-tmp -n simavr -v $(SIMAVR_VERSION) \
sim/simavr/Makefile:# ship with old version of avr-gcc and associated and needs
sim/simavr/Makefile:			echo WARNING $$file did not compile, check your avr-gcc toolchain; \
Binary file sim/tests/atmega48_watchdog_test.axf matches
Binary file sim/tests/attiny44_interrupt_irq_test.axf matches
Binary file sim/tests/attiny2313a_usi.axf matches
Binary file sim/tests/attiny85_spm_test.axf matches
Binary file sim/tests/atmega644_adc_test.axf matches
sim/tests/tests.c:	if (avr->state == cpu_Stopped)
sim/tests/tests.c:		return avr->state;
sim/tests/tests.c:	uint16_t new_pc = avr->pc;
sim/tests/tests.c:	if (avr->state == cpu_Running)
sim/tests/tests.c:	avr->pc = new_pc;
sim/tests/tests.c:	if (avr->state == cpu_Sleeping) {
sim/tests/tests.c:		if (!avr->sreg[S_I]) {
sim/tests/tests.c:		avr->cycle += 1 + sleep;
sim/tests/tests.c:	if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
sim/tests/tests.c:	return avr->state;
sim/tests/tests.c:	avr->custom.deinit = special_deinit_longjmp_cb;
sim/tests/tests.c:	tests_cycle_count = avr->cycle;
Binary file sim/tests/atmega168_ioport.axf matches
Binary file sim/tests/atmega88_ac_test.axf matches
Binary file sim/tests/atmega2560_uart_echo.axf matches
Binary file sim/tests/attiny84_usi.axf matches
Binary file sim/tests/atmega48_disabled_timer.axf matches
sim/tests/atmega2560_uart_echo.c:#ifdef USART3_RX_vect_num	// stupid ubuntu has antique avr-libc
sim/tests/atmega2560_uart_echo.c:	// see http://www.nongnu.org/avr-libc/user-manual/group__util__setbaud.html
Binary file sim/tests/atmega88_example.axf matches
Binary file sim/tests/attiny85_crash_gdb.axf matches
Binary file sim/tests/atmega88_coroutine.axf matches
Binary file sim/tests/atmega88_timer16.axf matches
Binary file sim/tests/atmega48_enabled_timer.axf matches
Binary file sim/tests/atmega644p_signature_read.axf matches
Binary file sim/tests/atmega2560_pin_change.axf matches
Binary file sim/tests/attiny85_adc_test.axf matches
sim/tests/atmega88_uart_echo.c:	// see http://www.nongnu.org/avr-libc/user-manual/group__util__setbaud.html
sim/tests/test_atmega2560_uart_echo.c:	avr->log = LOG_TRACE;
Binary file sim/tests/atmega88_uart_echo.axf matches
